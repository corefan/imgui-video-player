#ifndef __FragmentShadingRTT_H
#define __FragmentShadingRTT_H

const std::string SimpleFragmentShaderCode =
"#version 150\n"
"\n" 
"out vec4 out_color;\n"
"\n" 
" void main() {\n"
" 	out_color = vec4(1.0, 1.0, 1.0, 1.0);\n"
" }\n";

const std::string FragmentShaderCode = "#version 330 core\n"
"\n"
"// Interpolated values from the vertex shaders\n"
"in vec2 UV;\n"
"in vec3 Position_worldspace;\n"
"in vec3 Normal_cameraspace;\n"
"in vec3 EyeDirection_cameraspace;\n"
"in vec3 LightDirection_cameraspace;\n"
"\n"
"// Ouput data\n"
"layout(location = 0) out vec3 color;\n"
"\n"
"// Values that stay constant for the whole mesh.\n"
"uniform sampler2D myTextureSampler;\n"
"uniform mat4 MV;\n"
"uniform vec3 LightPosition_worldspace;\n"
"\n"
"void main(){\n"
"\n"
"	// Light emission properties\n"
"	// You probably want to put them as uniforms\n"
"	vec3 LightColor = vec3(1,1,1);\n"
"	float LightPower = 50.0f;\n"
"\n"
"	// Material properties\n"
"	vec3 MaterialDiffuseColor = texture( myTextureSampler, UV ).rgb;\n"
"	vec3 MaterialAmbientColor = vec3(0.1,0.1,0.1) * MaterialDiffuseColor;\n"
"	vec3 MaterialSpecularColor = vec3(0.3,0.3,0.3);\n"
"\n"
"	// Distance to the light\n"
"	float distance = length( LightPosition_worldspace - Position_worldspace );\n"
"\n"
"	// Normal of the computed fragment, in camera space\n"
"	vec3 n = normalize( Normal_cameraspace );\n"
"	// Direction of the light (from the fragment to the light)\n"
"	vec3 l = normalize( LightDirection_cameraspace );\n"
"	// Cosine of the angle between the normal and the light direction, \n"
"	// clamped above 0\n"
"	//  - light is at the vertical of the triangle -> 1\n"
"	//  - light is perpendiular to the triangle -> 0\n"
"	//  - light is behind the triangle -> 0\n"
"	float cosTheta = clamp( dot( n,l ), 0,1 );\n"
"	\n"
"	// Eye vector (towards the camera)\n"
"	vec3 E = normalize(EyeDirection_cameraspace);\n"
"	// Direction in which the triangle reflects the light\n"
"	vec3 R = reflect(-l,n);\n"
"	// Cosine of the angle between the Eye vector and the Reflect vector,\n"
"	// clamped to 0\n"
"	//  - Looking into the reflection -> 1\n"
"	//  - Looking elsewhere -> < 1\n"
"	float cosAlpha = clamp( dot( E,R ), 0,1 );\n"
"	\n"
"	color = \n"
"		// Ambient : simulates indirect lighting\n"
"		MaterialAmbientColor +\n"
"		// Diffuse : color of the object\n"
"		MaterialDiffuseColor * LightColor * LightPower * cosTheta / (distance*distance) +\n"
"		// Specular : reflective highlight, like a mirror\n"
"		MaterialSpecularColor * LightColor * LightPower * pow(cosAlpha,5) / (distance*distance);\n"
"\n"
"}\n";

#endif
